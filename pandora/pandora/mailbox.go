package pandora

// Copyright (c) 2014 AndrÃ© Luiz Alves Moraes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
import (
	"errors"
	"fmt"
	"github.com/andrebq/exp/pandora"
	"io/ioutil"
	"net/http"
	"net/url"
	"strconv"
	"time"
)

// AckStatus represent the status of the processing of the message
type AckStatus byte
const (
	// Confirm that the message was processed and remove it from the mailbox
	Confirm = AckStatus(pandora.StatusConfirmed)
	// Unable to process the message, put it back on the mailbox
	Reject = AckStatus(pandora.StatusRejected)
)

var (
	ErrNoData = errors.New("no data available")
)

// HttpClient defines the interface required to enable a Mailbox object
// to talk with a Pandora server
type HttpClient interface {
	// PostForm is used to send the given body values to the url
	PostForm(url string, body url.Values) (*http.Response, error)
}

// Mailbox is the most basic form o interaction with a pandora server.
type Mailbox struct {
	BaseUrl string
	Client  HttpClient
}

// Ack marks the message as processed or rejected
func (mb *Mailbox) Ack(mid, lid string, status AckStatus) error {
	msgToAck := make(url.Values)
	msgToAck.Set("mid", mid)
	msgToAck.Set("lid", lid)
	msgToAck.Set("statusCode", strconv.FormatInt(int64(status), 10))

	res, err := mb.Client.PostForm(mb.BaseUrl+"/ack", msgToAck)
	if err != nil {
		return err
	}
	defer res.Body.Close()

	if res.StatusCode != http.StatusOK {
		return fmt.Errorf("invalid status code: %v", res.StatusCode)
	}
	return nil
}

// Fetch asks for the server for a message
func (mb *Mailbox) Fetch(from string, lockFor time.Duration) (url.Values, error) {
	// now, try to consume the message
	msgToFetch := make(url.Values)
	msgToFetch.Set(pandora.KeyReceiver, from)
	msgToFetch.Set(pandora.KeyLeaseTime, lockFor.String())

	res, err := mb.Client.PostForm(mb.BaseUrl+"/fetch", msgToFetch)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	if res.StatusCode == http.StatusNoContent {
		return nil, ErrNoData
	}

	if res.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("invalid status code: %v", res.StatusCode)
	}

	buf, err := ioutil.ReadAll(res.Body)
	if err != nil {
		return nil, err
	}
	respValues, err := url.ParseQuery(string(buf))
	if err != nil {
		return nil, err
	}
	if len(respValues.Get("mid")) == 0 {
		return nil, fmt.Errorf("mid empty")
	}
	return respValues, nil
}

// Send will update the given body with the paramters expected by a Pandora server
// and return the Mid generated by the server or an error.
func (mb *Mailbox) Send(from, to string, delay time.Duration, body url.Values) (string, error) {
	var msg pandora.Message
	msg.Empty(body)
	msg.SetSender(from)
	msg.SetReceiver(to)
	msg.SetClientTime(time.Now())
	msg.Set("delay", delay.String())

	res, err := mb.Client.PostForm(mb.BaseUrl+"/send", body)
	if err != nil {
		return "", err
	}
	defer res.Body.Close()

	if res.StatusCode != http.StatusOK {
		return "", fmt.Errorf("invalid status code: %v", res.StatusCode)
	}

	buf, err := ioutil.ReadAll(res.Body)
	if err != nil {
		return "", err
	}

	values, err := url.ParseQuery(string(buf))
	if err != nil {
		return "", err
	}

	if len(values.Get("error")) > 0 {
		return "", errors.New(values.Get("error"))
	}

	return values.Get("mid"), nil
}
