package graphdb

import (
	"database/sql"
	"github.com/lib/pq/hstore"
	"math"
	"strings"
)

// Attributes define the structure used to represent
// the attributes of a given node.
//
// This map's directly to the hstore column type of postgres,
// with some pre-validation
type Attributes struct {
	data *hstore.Hstore
}

// Keyword define a Graph keyword, keywords are similar
// to strings but they are stored using much less space
// in the graph.
//
// All Keywords start with a :
type Keyword struct {
	name string
	code int
}

// NewKeyword return a formated Keyword representing the given
// string
func NewKeyword(keyword string) Keyword {
	if !strings.HasPrefix(keyword, ":") {
		keyword = ":" + keyword
	}
	return Keyword{keyword, math.MinInt32}
}

// Node is the representation of a graph node
type Node struct {
	Id uint64
	Kind Keyword
	contents []*nodeContent
}

type nodeContent struct {
	kind Keyword
	content hstore.Hstore
}

func newNodeContent(kind Keyword) nodeContent {
	return nodeContent{
		kind: kind,
		content: hstore.Hstore{
			Map: make(map[string]sql.NullString),
		},
	}
}

func (nc *nodeContent) set(name, value string) *nodeContent {
	nc.content.Map[name] = sql.NullString{Valid: true, String: value}
	return nc
}

// NewNode return a empty node of the given kind
func NewNode(kind Keyword) Node {
	return Node{Id: 0,
		Kind: kind,
		contents: make([]*nodeContent, 0),
	}
}

func (n *Node) SetValue(kind Keyword, propName, propValue string) *Node {
	for i, _ := range n.contents {
		if n.contents[i].kind.name == kind.name {
			n.contents[i].set(propName, propValue)
			return n
		}
	}
	nc := newNodeContent(kind)
	n.contents = append(n.contents, *nc.set(propName, propValue))
	return n
}
